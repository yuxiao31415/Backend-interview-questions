## 从前端发送请求到spring mvc的过程
①、发起请求：客户端通过 HTTP 协议向服务器发起请求。  
②、前端控制器：这个请求会先到前端控制器 DispatcherServlet，它是整个流程的入口点，负责接收请求并将其分发给相应的处理器。  
③、处理器映射：DispatcherServlet 调用 HandlerMapping 来确定哪个 Controller 应该处理这个请求。通常会根据请求的 URL 来确定。  
④、处理器适配器：一旦找到目标 Controller，DispatcherServlet 会使用 HandlerAdapter 来调用 Controller 的处理方法。  
⑤、执行处理器：Controller 处理请求，处理完后返回一个 ModelAndView 对象，其中包含模型数据和逻辑视图名。  
⑥、视图解析器：DispatcherServlet 接收到 ModelAndView 后，会使用 ViewResolver 来解析视图名称，找到具体的视图页面。  
⑦、渲染视图：视图使用模型数据渲染页面，生成最终的页面内容。  
⑧、响应结果：DispatcherServlet 将视图结果返回给客户端。  
## 介绍下AOP  
AOP，也就是 Aspect-oriented Programming，译为面向切面编程。  
就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。  
AOP 的核心概念包括切面（Aspect）、连接点（Join Point）、通知（Advice）、切点（Pointcut）和织入（Weaving）等。  
① 像日志打印、事务管理等都可以抽离为切面，可以声明在类的方法上。  
② 在 Spring AOP 中，连接点总是表示方法的执行。  
③ Spring AOP 支持五种类型的通知：前置通知、后置通知、环绕通知、异常通知、最终通知等。  
④ 在 AOP 中，切点用于指定我们想要在哪些连接点上执行通知的规则。  
⑤ 织入是指将切面应用到目标对象并创建新的代理对象的过程。Spring AOP 默认在运行时通过动态代理方式实现织入。  
## sleep和wait的区别   
① 所属类：  
sleep() 方法专属于 Thread 类。    
wait() 方法专属于 Object 类。    
② 锁行为：  
当线程执行 sleep 方法时，它不会释放任何锁。也就是说，如果一个线程在持有某个对象的锁时调用了 sleep，它在睡眠期间仍然会持有这个锁。 
而调用wait方法则会释放所持有的对象锁  
③ 使用条件：  
sleep() 方法可以在任何地方被调用。  
wait() 方法必须在同步代码块或同步方法中被调用，这是因为调用 wait() 方法的前提是当前线程必须持有对象的锁。否则会抛出 IllegalMonitorStateException 异常  
④ 唤醒方式：
sleep() 方法在指定的时间过后，线程会自动唤醒继续执行。  
wait() 方法需要依靠 notify()、notifyAll() 方法或者 wait() 方法中指定的等待时间到期来唤醒线程。  
## JVM 的组织架构  
① 类加载器  
负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。  
② 运行时数据区  
JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、栈、程序计数器和本地方法栈。  
③ 执行引擎  
执行引擎是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）  
## Java 解释执行的流程  
1. Java 的执行方式  
Java 被称为“解释型语言”：Java 代码在执行之前，需要先将源代码编译成 字节码，字节码是平台无关的中间表示。  
字节码执行：在程序运行时，JVM 的解释器将字节码逐行转换为机器码并执行。  
2. Java 执行的性能瓶颈  
解释执行需要逐行翻译，造成执行速度较慢。   
3. JIT（Just-In-Time）编译的优化   
JIT 编译：JVM 会监视程序的运行，并将热点代码（运行频率较高的代码）编译成机器码，存储在 CodeCache。   
热点代码：下次执行时，JVM 不再逐行解释，而是直接从 CodeCache 读取机器码执行，显著提升性能。
## 分布式锁用了 Redis 的什么数据结构   
在使用 Redis 实现分布式锁时，通常使用 Redis 的字符串（String）。Redis 的字符串是最基本的数据类型，一个键对应一个值，它能够存储任何形式的字符串，包括二进制数据。字符串类型的值最多可以是 512MB。 
Redis 实现分布式锁的本质，就是在 Redis 里面占一个位置，当别的进程也来占位时，发现已经有进程，就只好放弃或者稍后再试。 
``SET lock_key value NX PX 30000``
```
lock_key 是锁的名称
value 是锁的唯一标识（通常是 UUID）
NX 表示只有在该键不存在时才会设置锁
PX 30000 设置锁的过期时间为 30 秒，避免死锁
```
## redis为什么读写性能高  
①、基于内存的数据存储，Redis 将数据存储在内存当中，使得数据的读写操作避开了磁盘 I/O。而内存的访问速度远超硬盘，这是 Redis 读写速度快的根本原因。  
②、单线程模型，Redis 使用单线程模型来处理客户端的请求，这意味着在任何时刻只有一个命令在执行。这样就避免了线程切换和锁竞争带来的消耗。  
③、IO 多路复⽤，基于 Linux 的 select/epoll 机制。该机制允许内核中同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接请求或者数据请求，一旦有请求到达，就会交给 Redis 处理，就实现了所谓的 Redis 单个线程处理多个 IO 读写的请求。  
④、高效的数据结构，Redis 提供了多种高效的数据结构，如字符串（String）、列表（List）、集合（Set）、有序集合（Sorted Set）等，这些数据结构经过了高度优化，能够支持快速的数据操作。  
## MySQL 的内联、左联、右联的区别  
①、inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。  
②、left join 返回左表（FROM 子句中指定的表）的所有记录，以及右表中匹配记录的记录。如果右表中没有匹配的记录，则结果中右表的部分会以 NULL 填充。  
③、right join 刚好与左联相反，返回右表（FROM 子句中指定的表）的所有记录，以及左表中匹配记录的记录。如果左表中没有匹配的记录，则结果中左表的部分会以 NULL 填充。  
## 看门狗的相关用法
Redisson会：
给锁设置默认过期时间： 
``30秒（lockWatchdogTimeout）``
启动一个后台线程（看门狗）    
每隔：  
``10秒（30秒的1/3）``  
自动执行：  
``延长锁的过期时间到30秒``  
## 手撕代码  
一个不均匀绳子烧60min，两个这样的绳子怎么确定15分钟      
**coin填amount的背包问题**   
https://leetcode.cn/problems/coin-change/description/  
```java
```
**二叉树计算节点作为root构成的树的平均大小**  
https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/  
```java

``` 
