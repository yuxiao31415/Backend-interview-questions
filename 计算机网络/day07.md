# TCP连接三次握手的过程，为什么是三次，可以是两次或者更多吗？ 
<img width="1080" height="813" alt="image" src="https://github.com/user-attachments/assets/1e22f02a-c30f-4639-8544-50dfa9bcd8db" />  

(1) 三次握手的过程   
第一次握手：客户端向服务器发送一个SYN （同步序列编号）报文，请求建立连接，客户端进入SYN_SENT 状态。  
第二次握手：服务器收到SYN 报文后，如果同意建立连接，则会发送一个SYN-ACK （同步确认）报文作为响应，同时进入SYN_RCVD 状态。  
第三次握手：客户端收到服务器的SYN-ACK 报文后，会发送一个ACK （确认）报文作为最终响应，之后客户端和服务器都进入ESTABLISHED 状态，连接建立成功。  
(2)为什么需要三次握手  
TCP 是全双工通信，要确认双方都具有收发能力  
第一次握手 客户端发送能力正常   
第二次握手 服务端收发能力正常   
第三次握手 客户端接收能力正常   
而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，
比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，
服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。而四次握手可以优化为三次。  
# TCP连接四次挥手的过程，为什么是四次？  
<img width="1334" height="1156" alt="image" src="https://github.com/user-attachments/assets/4c3e83a0-8c2c-4f85-a8fb-fc21f305dd50" />  

（1）四次挥手的过程   
①、第一次挥手：客户端向服务器发送一个 FIN(seq=x)结束报文，表示客户端没有数据要发送了，但仍然可以接收数据。客户端进入 FIN-WAIT-1 状态。  
②、第二次挥手：服务器接收到 FIN 报文后，向客户端发送一个 ACK(seq=x+1) 报文，确认已接收到客户端的 FIN 请求。服务器进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。   
③、第三次挥手：服务器向客户端发送一个 FIN(seq=y) 报文，表示服务器也没有数据要发送了。服务器进入 LAST-ACK 状态。   
④、第四次挥手：客户端接收到 FIN 报文后，向服务器发送一个 ACK(seq=y+1) 报文，确认已接收到服务器的 FIN 请求。客户端进入 TIME-WAIT 状态，等待一段时间以确保服务器接收到 ACK 报文。服务器接收到 ACK 报文后进入 CLOSED 状态。客户端在等待一段时间后也进入 CLOSED 状态。  
 
（2）为什么需要四次挥手   
2 次 FIN + 2 次 ACK = 四次挥手   
第一次挥手表明客户端已经没有数据要发送了  
第二次挥手表示服务端已经知道了  
第三次挥手表示服务端也已经没有数据要发送了  
第四次握手表示客户端已经知道服务端已经没有数据发送了  
然后服务端关闭  而客户端等待一会看最后一个ack报文是否发送给服务端    
# HTTP的Keep-Alive是什么？TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？  
HTTP 的 Keep-Alive，是由应用层实现的，称为 HTTP 长连接 :  
每次请求都要经历这样的过程：建立 TCP连接 -> HTTP请求资源 -> 响应资源 -> 释放连接，这就是HTTP短连接，
但是这样每次建立连接都只能请求一次资源，所以HTTP 的 Keep-Alive实现了使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，
避免了连接建立和释放的开销，就就是 HTTP 长连接。通过设置HTTP头Connection: keep-alive来实现。  

TCP 的 Keepalive，是由TCP 层（内核态）实现的，称为 TCP 保活机制:  
是一种用于在 TCP 连接上检测空闲连接状态的机制
当TCP连接建立后，如果一段时间内没有任何数据传输，TCP Keepalive会发送探测包来检查连接是否仍然有效。  
