## ThreadLocal 什么情况下会内存泄漏  
①、线程池中的线程
线程池中的线程会被重复利用。如果在每个线程中使用 ThreadLocal 存储数据，且没有手动清理线程局部变量（例如调用 ThreadLocal.remove()），那么当线程池中的线程被复用时，这些线程仍然持有对 ThreadLocal 对象的强引用。由于 ThreadLocal 的键是弱引用，可能导致 ThreadLocalMap 中的条目无法被垃圾回收，导致内存泄漏。
②、线程生命周期过长
如果使用 ThreadLocal 的线程生命周期非常长（例如，长期运行的线程或线程池中的线程），而线程中的 ThreadLocal 存储没有及时清除，那么这个线程所持有的 ThreadLocalMap 中的引用会一直存在，导致内存泄漏。 
## Thread ThreadLocal ThreadLocalMap
Thread:线程类  
ThreadLocal: 线程局部变量,线程类内部有一个ThreadLocal.ThreadLocalMap类型的threadlocals成员变量  
ThreadLocalMap:是ThreadLocal的静态内部类  
## Spring AOP实现原理  
Spring 的 AOP 是通过动态代理来实现的，动态代理主要有两种方式：JDK 动态代理和 CGLIB 代理。    
①、JDK 动态代理是基于接口的代理方式，它使用 Java 原生的 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来创建和管理代理对象。  
基于 Interface：JDK 动态代理要求目标对象必须实现一个或多个接口。代理对象不是直接继承自目标对象，而是实现了与目标对象相同的接口。  
使用 InvocationHandler：在调用代理对象的任何方法时，调用都会被转发到一个 InvocationHandler 实例的 invoke 方法。可以在这个 invoke 方法中定义拦截逻辑，比如方法调用前后执行的操作。  
基于 Proxy：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口实例，生成目标类的代理对象。  
②、CGLIB（Code Generation Library）是一个第三方代码生成库，它通过继承方式实现代理，不需要接口，被广泛应用于 Spring AOP 中，用于提供方法拦截操作。  
基于继承，CGLIB 通过在运行时生成目标对象的子类来创建代理对象，并在子类中覆盖非 final 的方法。因此，它不要求目标对象必须实现接口。  
基于 ASM，ASM 是一个 Java 字节码操作和分析框架，CGLIB 可以通过 ASM 读取目标类的字节码，然后修改字节码生成新的类。它在运行时动态生成一个被代理类的子类，并在子类中覆盖父类的方法，通过方法拦截技术插入增强代码。    
## 单例模式  
单例模式确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式主要用于控制对某些共享资源的访问，例如配置管理器、连接池、线程池、日志对象等。  
